Before any optimization (integrator, time in milliseconds, result):
  RK4: 1728 [-0.004324479859109162, -0.004324479859109162, -0.004324479859109162]
MidEu: 1780 [-0.0002752926537500928, -0.0002752926537500928, -0.0002752926537500928]
exact:      [0.0, 0.0, 0.0]
The code performs so poorly that the algorithmically inferior midpoint Euler smashes RK4.

//btw, dFinal in RK4 was mutating input but midpoint euler wasn't (apples to oranges comparison)
After ScaleMut:
  RK4: 1348 [-0.004324479859109162, -0.004324479859109162, -0.004324479859109162]
MidEu: 956 [-0.0002752926537500928, -0.0002752926537500928, -0.0002752926537500928]
exact: [0.0, 0.0, 0.0]

+AddMut:
  RK4: 928 [-0.004324479859109162, -0.004324479859109162, -0.004324479859109162]
MidEu: 911 [-0.0002752926537500928, -0.0002752926537500928, -0.0002752926537500928]
exact: [0.0, 0.0, 0.0]

//Changed integration to allow mutation of input Displacement and Velocity
+DivideMut:
  RK4: 648 [-0.004324479859109162, -0.004324479859109162, -0.004324479859109162]
MidEu: 467 [-0.0002752926537500928, -0.0002752926537500928, -0.0002752926537500928]
exact: [0.0, 0.0, 0.0]
//NOTE: DivideMut actually slows midpoint Euler by 20-30ms, so not using it there. It benefits Rk4 though.

